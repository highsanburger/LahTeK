\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{tikz}
\usepackage{tikz-cd}

\usepackage{minted}

\begin{document}

\title{Answers to Category Theory Questions}
\author{Your Name}
\date{\today}
\maketitle

\section{Ch-1 Category}
\begin{enumerate}
	\item \textbf{Implement, as best as you can, the identity function in your favorite language (or the second favorite, if your favorite language happens to be Haskell).}

	      \textbf{Answer:}
	      \begin{verbatim}
    function id(f) { return f }
    \end{verbatim}

	\item \textbf{Implement the composition function in your favorite language. It takes two functions as arguments and returns a function that is their composition.}

	      \textbf{Answer:}
	      \begin{verbatim}
    const compose = (funcA, funcB) => x => funcA(funcB(x));
    \end{verbatim}

	\item \textbf{Write a program that tries to test that your composition function respects identity.}

	      \textbf{Answer:}
	      \begin{verbatim}
    function square(x) { return x ** 2 }
    function sqrt(x) { return x ** (1 / 2) }

    // Test composition and identity
    // ... (your test code here)
    \end{verbatim}

	\item \textbf{Is the world-wide web a category in any sense? Are links morphisms?}

	      \textbf{Answer:}
	      \begin{align*}
		       & \text{WWW is a category if and only if all sites link to each other and each site links to itself} \\
		       & \text{and since it actually doesn't, it's not.}                                                    \\
		       & \begin{aligned}
			          & \text{a. Objects - web pages}                                                               \\
			          & \text{b. Morphisms - linking two web pages}                                                 \\
			          & \text{c. Composition - clicking two links one after the other same as clicking direct link} \\
			          & \text{i) Associativity - since all sites are interlinked routes don't matter}               \\
			          & \text{ii) Identity - going from H to A then A to A}
		         \end{aligned}
	      \end{align*}

	\item \textbf{Is Facebook a category, with people as objects and friendships as morphisms?}

	      \textbf{Answer:}
	      \begin{align*}
		       & \text{Facebook}                                                                                                                 \\
		       & \begin{aligned}
			          & \text{a. Objects - people}                                                                                                   \\
			          & \text{b. Morphisms - friendships}                                                                                            \\
			          & \text{c. Composition - if A is a friend of B and if B is a friend of C does not necessarily entail that A \& C are friends.}
		         \end{aligned}
	      \end{align*}
	      Hence no FB is not a category.

	\item \textbf{When is a directed graph a category?}

	      \textbf{Answer:}
	      \begin{align*}
		       & \text{A directed graph is a category if and only if}                            \\
		       & \begin{aligned}
			          & \text{i) each vertice is linked to / has an adjacency to itself.}            \\
			          & \text{ii) all vertices are interconnected with at least a one-way adjacency}
		         \end{aligned}
	      \end{align*}
\end{enumerate}

\section{Ch-2 Types}
\begin{enumerate}
	\item \textbf{Define a higher-order function (or a function object) \texttt{memoize} in your favorite language. This function takes a pure function \texttt{f} as an argument and returns a function that behaves almost exactly like \texttt{f}, except that it only calls the original function once for every argument, stores the result internally, and subsequently returns this stored result every time it’s called with the same argument.}

	      \textbf{Answer:}
	      \begin{verbatim}
    function memoize(f) { }
    \end{verbatim}

	\item \textbf{Try to memoize a function from your standard library that you normally use to produce random numbers. Does it work?}

	      \textbf{Answer:}
	      \begin{verbatim}
    % Your response here
    \end{verbatim}

	\item \textbf{Most random number generators can be initialized with a seed. Implement a function that takes a seed, calls the random number generator with that seed, and returns the result. Memoize that function. Does it work?}

	      \textbf{Answer:}
	      \begin{verbatim}
    % Your response here
    \end{verbatim}

	\item \textbf{Which of these C++ functions are pure? Try to memoize them and observe what happens when you call them multiple times: memoized and not.}
	      \begin{enumerate}[(a)]
		      \item The factorial function from the example in the text.
		      \item \texttt{std::getchar()}
		      \item \texttt{bool f() \{ std::cout << "Hello!" << std::endl; return true; \}}
		      \item \texttt{int f(int x) \{ static int y = 0; y += x; return y; \}}
	      \end{enumerate}

	      \textbf{Answer:}
	      \begin{verbatim}
    % Your response here
    \end{verbatim}

	\item \textbf{How many different functions are there from Bool to Bool? Can you implement them all?}

	      \textbf{Answer:}
	      \begin{align*}
		       & f : \text{Bool} \to \text{Bool}          \\
		       & \text{id} = (\text{T,T}) , (\text{F,F})  \\
		       & \text{not} = (\text{T,F}) , (\text{F,T}) \\
		       & \text{tru} = (\text{T,T}) , (\text{F,T}) \\
		       & \text{fal} = (\text{T,F}) , (\text{F,F})
	      \end{align*}

	\item \textbf{Draw a picture of a category whose only objects are the types \texttt{Void}, \texttt{()} (unit), and \texttt{Bool}; with arrows corresponding to all possible functions between these types. Label the arrows with the names of the functions.}

	      \begin{tikzcd}
		      Bool \arrow["id" description, loop, distance=2em, in=305, out=235] \arrow["{not, true,false}"', dashed, loop, distance=2em, in=125, out=55] \arrow[rr, "()" description] &      & () \arrow["id" description, loop, distance=2em, in=305, out=235] \arrow[ll, "True" description, bend right] \arrow[ll, "False" description, bend left] \\
		      & Void &
	      \end{tikzcd}

	      And also counter intuitively, you have single morphisms from \textit{Void}  to \textit{Bool } and $ () $ called \textbf{absurd.} And also $ id_{\textit{Void}}$.
\end{enumerate}

\section{ Ch-3 Categories Great and Small}
\begin{enumerate}
	\item \textbf{ Generate a free category from:}
	      \begin{enumerate}
		      \item A graph with one node and no edges. \\
		            \begin{tikzcd}
			            o \arrow["id",loop, distance=2em, in=305, out=235]
		            \end{tikzcd}
		      \item A graph with one node and one (directed) edge (hint: this edge can be composed with itself). \\
		            \begin{tikzcd}
			            o \arrow["id"', loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=35, out=325]
		            \end{tikzcd}
		      \item A graph with two nodes and a single arrow between them. \\
		            \begin{tikzcd}
			            o \arrow["id", loop, distance=2em, in=305, out=235] \arrow[rr] &  & o \arrow["id", loop, distance=2em, in=305, out=235]
		            \end{tikzcd}
		      \item A graph with a single node and 26 arrows marked with the letters of the alphabet: a, b, c … z. \\
		            \begin{tikzcd}
			            o \arrow["id"', loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=305, out=235] \arrow["a" description, dashed, loop, distance=2em, in=215, out=145] \arrow[loop, distance=2em, in=305, out=235] \arrow[loop, distance=2em, in=305, out=235] \arrow["b" description, dashed, loop, distance=2em, in=125, out=55] \arrow["...z" description, dashed, loop, distance=2em, in=35, out=325] \arrow[loop, distance=2em, in=305, out=235]
		            \end{tikzcd}
	      \end{enumerate}

	\item \textbf{ What kind of order is this?}
	      \begin{enumerate}
		      \item \textbf{ A set of sets with the inclusion relation: $A$ is included in $B$ if every element of $A$ is also an element of $B$.}\\
		            Same as saying, $ A \subseteq B $. Now,
		            \begin{enumerate}
			            \item If $ A \subseteq B $ and $ B \subseteq C $ then $ A \subseteq C $
			            \item If $ A \subseteq B $ 	and $ B \subseteq A $ then $ A = B $.
			            \item There can exist sets $ A , B  $ such that $ A \not \subseteq B $ and $ B \not \subseteq A $.
		            \end{enumerate}
		            Therefore this is a \textit{partially ordered} set.
		      \item \textbf{ What kind of order is this? C++ types with the following subtyping relation: $T1$ is a subtype of $T2$ if a pointer to $T1$ can be passed to a function that expects a pointer to $T2$ without triggering a compilation error.} \\
		            \textit{TODO}
	      \end{enumerate}
	\item \textbf{ Considering that Bool is a set of two values True and False, show that it forms two (set-theoretical) monoids with respect to, respectively, the operator $\&\&$ (AND) and $||$ (OR).} \\
	      \begin{tikzcd}
		      Bool  \arrow["{AND \, \,\, True = id}"', loop, distance=2em, in=35, out=325] \arrow["{AND \, \,\, False}"', loop, distance=2em, in=215, out=145] \\
		      Bool \arrow["{OR \, \,\, False = id}"', loop, distance=2em, in=215, out=145] \arrow["{OR \, \,\, True}"', loop, distance=2em, in=35, out=325]
	      \end{tikzcd}

	      In haskell: \begin{verbatim}
mempty1 = True
mappend1 = AND 
mempty2 = False
mappend2 = OR
\end{verbatim}
	      \
	\item \textbf{ Represent the Bool monoid with the AND operator as a category. List the morphisms and their rules of composition.}

	      Morphisms - AND True, AND False

	      Rule of composition - AND True $ \rightarrow $  AND False = AND False

	      (i.e AND True is id)
	\item \textbf{ Represent addition modulo 3 as a monoid category.}

	      \begin{tikzcd}
		      {\{0,1,2\}} \arrow["+1"', loop, distance=2em, in=305, out=235] \arrow["+2"', loop, distance=2em, in=35, out=325] \arrow["id=+0"', loop, distance=2em, in=215, out=145]
	      \end{tikzcd}


\end{enumerate}

\section{ Ch-4 Kleisli Categories}
\begin{enumerate}
	\item \textbf{ Construct the Kleisli category for partial functions (define composition and identity).}

	      \begin{minted}{haskell}
			
(>->) :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
f >-> g = \x -> case  f x of
            Nothing -> Nothing
            Just b  -> g b
kid :: (a -> Maybe a)
kid = Just 
	      \end{minted}
	\item \textbf{ Implement the embellished function \textit{safe\_reciprocal} that returns a valid reciprocal of its argument, if it’s different from zero. }

	      \begin{minted}{haskell}
safe_reciprocal :: Double -> Maybe Double
safe_reciprocal 0 = Nothing 
safe_reciprocal n = Just (1/n)

safe_root :: Double -> Maybe Double
safe_root n | n >= 0    = Just $ sqrt n
            | otherwise = Nothing
\end{minted}
	\item \textbf{Compose the functions \textit{safe\_root} and \textit{safe\_reciprocal} to implement \textit{safe\_root\_reciprocal} that calculates \textit{sqrt(1/x)} whenever possible.}

	      \begin{minted}{haskell}
safe_root_reciprocal :: Double -> Maybe Double 
safe_root_reciprocal = safe_root >-> safe_reciprocal

		\end{minted}
\end{enumerate}

\section{Ch5 Products \& Coproducts}
\begin{enumerate}
	\item \textbf{Show that the terminal object is unique up to unique isomorphism.}
	\item \textbf{What is a product of two objects in a poset? Hint: Use the universal construction.}
	\item \textbf{What is a coproduct of two objects in a poset?}
	\item \textbf{Implement the equivalent of Haskell \textit{Either} as a generic type in your favorite language (other than Haskell).}
	\item \textbf{Show that \textit{Either} is a "better" coproduct than \textit{int} equipped with two injections:}
	      \begin{minted}{cpp}
		int i(int n) { return n; }	
		int j(bool b) { return b ? 0: 1; }
		\end{minted}
	      Hint: Define a function
	      \begin{minted}{cpp}
		int m(Either const & e);	
		\end{minted}
	      that factorizes \textit{i} and \textit{j}.
	\item \textbf{Continuing the previous problem: How would you argue that \textit{int} with the two injections \textit{i} and \textit{j} cannot be "better" than \textit{Either} ?}
	\item \textbf{Still continuing: What about these injections?}
	      \begin{minted}{cpp}
		int i(int n) {
			if (n < 0) return n;
			return n + 2;
		}
		
		int j(bool b) { return b ? 0: 1; }
		\end{minted}
	\item \textbf{Come up with an inferior candidate for a coproduct of \textit{int} and \textit{bool} that cannot be better than \textit{Either} because it allows multiple acceptable morphisms from it to \textit{Either}.}
\end{enumerate}

\section{Ch6 Algebraic Data Types}

\begin{enumerate}
	\item \textbf{Show the isomorphism between \textit{Maybe a} and \textit{Either () a}.}
	\item \textbf{Here's a sum type defined in Haskell:}

	      \begin{minted}{haskell}
		data Shape = Circle Float | Rect Float Float
		\end{minted}
	      \textbf{When we want to define a function like \textit{area} that acts on a \textit{Shape} , we do it by pattern matching on the two constructors: }
	      \begin{minted}{haskell}
area :: Shape -> Float 
area (Circle r) = pi * r * r
area (Rect d h) = d * h
\end{minted}
	      \textbf{Implement \textit{Shape} in C++ or Java as an interface and create two classes: \textit{Circle} and \textit{Rect}. Implement \textit{area} as a virtual function.}

	\item \textbf{Continuing with the previous example: We can easily add a new function \textit{circ} that calculates the circumference of a \textit{Shape}. We can do it without touching the definition of \textit{Shape}:  }
	      \begin{minted}{haskell}
	      circ :: Shape -> Float
	      circ (Circle r) = 2.0 * pi * r
	      circ (Rect d h) = 2.0 * (d + h)
	      \end{minted}
	      \textbf{Add \textit{circ} to your Cpp or Java implementation. What parts of the original code did you have to touch?}


	\item \textbf{Continuing further: Add a new shape, \textit{Square} , to \textit{Shape} and make all the necessary updates. What code did you have to touch in Haskell vs. Cpp or Java? }

	\item \textbf{Show that $ a + a = 2 \times a $ holds for types (up to isomorphism). Remember that $ 2 $ corresponds to \textit{Bool} , according to our translation table.}
\end{enumerate}

\end{document}

